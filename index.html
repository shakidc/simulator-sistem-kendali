<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TM UNIMAL: Simulator Sistem Kendali Motor Listrik</title>
    <link rel="icon" type="image/png" href="logo.png">

    <!-- Pustaka eksternal -->
    <script src="https://cdn.plot.ly/plotly-2.29.1.min.js"></script>
    <script>
        // Konfigurasi MathJax untuk merender persamaan LaTeX
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

    <style>
        /* Skema Warna & Font (Dark Theme) */
        :root {
            --color-bg: #1e1e1e;
            --color-bg-panel: #2a2a2a;
            --color-container: #252526;
            --color-border: #4a4a4a;
            --color-text: #d4d4d4;
            --color-text-dim: #9e9e9e;
            --color-primary: #00aaff;
            --color-secondary: #00ffaa;
            --color-danger: #ff5577;
            --color-warning: #ffee88;
            --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-mono: 'Courier New', Courier, monospace;
        }
        
        body {
            font-family: var(--font-main);
            background-color: var(--color-bg);
            color: var(--color-text);
            line-height: 1.6;
            margin: 0;
            padding: 24px;
        }

        h1, h2, h3 {
            color: var(--color-primary);
            border-bottom: 2px solid var(--color-border);
            padding-bottom: 8px;
            margin-top: 20px;
        }
        
        h1 { text-align: center; }

        /* Layout Utama Grid */
        .main-container {
            display: grid;
            grid-template-columns: 420px 1fr;
            gap: 24px;
            max-width: 1800px;
            min-height: 90vh;
            margin: 20px auto;
            background-color: var(--color-container);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border: 1px solid var(--color-border);
            overflow: hidden;
        }

        .controls-panel {
            padding: 24px;
            border-right: 1px solid var(--color-border);
            background-color: var(--color-bg-panel);
            overflow-y: auto;
        }

        .simulation-panel {
            padding: 24px;
            overflow-y: auto;
        }

        /* Kontrol UI (Slider, Details, dll) */
        details {
            margin-bottom: 20px;
            background: var(--color-container);
            border: 1px solid var(--color-border);
            border-radius: 8px;
        }
        
        details[open] summary {
            border-bottom: 1px solid var(--color-border);
        }

        summary {
            font-weight: bold;
            font-size: 1.2em;
            color: var(--color-primary);
            padding: 12px;
            cursor: pointer;
            list-style: none; /* Hapus marker default */
        }
        
        summary::-webkit-details-marker { display: none; } /* Chrome */
        summary::marker { display: none; } /* Firefox */

        summary:before {
            content: '► ';
            color: var(--color-primary);
            margin-right: 8px;
            transition: transform 0.2s ease-in-out;
            display: inline-block;
        }
        
        details[open] summary:before {
            transform: rotate(90deg);
        }
        
        .control-group {
            padding: 16px;
        }

        .slider-container {
            margin-bottom: 15px;
        }

        .slider-container label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--color-text);
        }
        
        .slider-container label .symbol {
            font-style: italic;
            font-size: 1.1em;
            color: var(--color-secondary);
        }

        .slider-container input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--color-primary);
        }

        .slider-container .value-display {
            font-weight: bold;
            color: var(--color-primary);
            float: right;
        }
        
        select, input[type="checkbox"] {
            background-color: var(--color-bg-panel);
            color: var(--color-text);
            border: 1px solid var(--color-border);
            border-radius: 4px;
            padding: 5px;
            margin-right: 5px;
        }

        /* Tampilan Persamaan (TF) */
        .tf-display-box {
            background: #1a1a1a;
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .tf-display-box h3 {
            margin-top: 0;
        }

        /* Analisis */
        .analysis-box {
            background: var(--color-bg-panel);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .analysis-box h3 {
            margin-top: 0;
            color: var(--color-secondary);
        }
        
        .analysis-box table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .analysis-box th, .analysis-box td {
            border-bottom: 1px solid var(--color-border);
            padding: 8px;
            text-align: left;
        }
        
        .analysis-box th {
            color: var(--color-text-dim);
            font-size: 0.9em;
        }
        
        .analysis-box td {
            font-weight: bold;
            font-family: var(--font-mono);
            font-size: 1.1em;
        }

        .analysis-box ul {
            list-style: none;
            padding: 0;
        }
        .analysis-box li {
            font-family: var(--font-mono);
            font-size: 1.1em;
            background: #333;
            padding: 5px 10px;
            border-radius: 4px;
            margin-bottom: 5px;
        }
        
        .analysis-box .desc {
            font-size: 0.9em;
            color: var(--color-text-dim);
            margin-top: 15px;
            border-top: 1px dashed var(--color-border);
            padding-top: 10px;
        }

        /* Interpretation Box */
        .interpretation-box {
            background-color: #1c2a38;
            border: 1px solid var(--color-primary);
            border-left: 5px solid var(--color-primary);
            padding: 20px;
            border-radius: 8px;
            margin-top: 24px;
        }
        .interpretation-box h3 {
            color: var(--color-primary);
            margin-top: 0;
        }
        .interpretation-box p {
            margin-bottom: 15px;
        }
        .interpretation-box strong {
            color: var(--color-secondary);
        }
        .interpretation-box code {
            background-color: #333;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: var(--font-mono);
        }
        .interpretation-box .good { color: var(--color-secondary); }
        .interpretation-box .bad { color: var(--color-danger); }
        .interpretation-box .warn { color: var(--color-warning); }


        /* Plotly Container */
        #plot-container {
            width: 100%;
            height: 550px;
            border: 1px solid var(--color-border);
            border-radius: 8px;
        }

        /* Penjelasan Teori */
        .theory-box {
            background-color: #2c2c1d;
            border: 1px solid var(--color-warning);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 24px;
            color: #f0f0f0;
        }
        .theory-box h2 {
            color: var(--color-warning);
            margin-top: 0;
        }
        
        .hidden { display: none; }
    </style>
</head>
<body>

    <div class="main-container">
        
        <div class="controls-panel">
            <h1>Panel Simulator</h1>

            <details open>
                <summary>1. Sistem Plant (Motor)</summary>
                <div class="control-group">
                    <label for="plant-type" style="font-weight: bold;">Pilih Model Plant Motor:</label>
                    <select id="plant-type" style="width: 100%;">
                        <option value="1">a. Orde 1: Kendali Kecepatan (Induktansi La ≈ 0)</option>
                        <option value="2">b. Orde 2: Kendali Posisi (Motor Orde 1)</option>
                        <option value="3">c. Orde 2: Kendali Kecepatan (Induktansi La ≠ 0)</option>
                    </select>
                </div>
            </details>
            
            <details open>
                <summary>2. Parameter Plant (G_p(s))</summary>
                
                <div id="params-k-tau" class="control-group">
                    <div class="slider-container">
                        <label for="k">Gain (<span class="symbol">K</span>): 
                            <span class="value-display" id="k-val">2.0</span>
                        </label>
                        <input type="range" id="k" min="0.1" max="10.0" value="2.0" step="0.1">
                    </div>
                    <div class="slider-container">
                        <label for="tau">Konstanta Waktu (<span class="symbol">&tau;</span>): 
                            <span class="value-display" id="tau-val">0.5</span>
                        </label>
                        <input type="range" id="tau" min="0.1" max="5.0" value="0.5" step="0.1">
                    </div>
                </div>

                <div id="params-zeta-wn" class="control-group hidden">
                    <div class="slider-container">
                        <label for="k_ord2">Gain (<span class="symbol">K</span>): 
                            <span class="value-display" id="k_ord2-val">1.0</span>
                        </label>
                        <input type="range" id="k_ord2" min="0.1" max="10.0" value="1.0" step="0.1">
                    </div>
                    <div class="slider-container">
                        <label for="zeta">Rasio Redaman (<span class="symbol">&zeta;</span>): 
                            <span class="value-display" id="zeta-val">0.2</span>
                        </label>
                        <input type="range" id="zeta" min="0.0" max="2.0" value="0.2" step="0.05">
                    </div>
                    <div class="slider-container">
                        <label for="omega_n">Frekuensi Natural (<span class="symbol">&omega;<sub>n</sub></span>): 
                            <span class="value-display" id="omega_n-val">5.0</span>
                        </label>
                        <input type="range" id="omega_n" min="0.1" max="20.0" value="5.0" step="0.1">
                    </div>
                </div>
            </details>

            <details open>
                <summary>3. Konfigurasi Kendali (Loop)</summary>
                
                <div class="control-group">
                    <div>
                        <input type="checkbox" id="pid-enable">
                        <label for="pid-enable"><b>Aktifkan Kendali PID (C(s))</b></label>
                    </div>
                    <div class="slider-container hidden" id="pid-params">
                        <label for="kp">Proporsional ($K_p$): 
                            <span class="value-display" id="kp-val">1.0</span>
                        </label>
                        <input type="range" id="kp" min="0.0" max="20.0" value="1.0" step="0.1">
                        
                        <label for="ki">Integral ($K_i$): 
                            <span class="value-display" id="ki-val">0.5</span>
                        </label>
                        <input type="range" id="ki" min="0.0" max="10.0" value="0.5" step="0.1">
                        
                        <label for="kd">Derivatif ($K_d$): 
                            <span class="value-display" id="kd-val">0.1</span>
                        </label>
                        <input type="range" id="kd" min="0.0" max="10.0" value="0.1" step="0.1">
                    </div>
                </div>

                <div class="control-group">
                    <div>
                        <input type="checkbox" id="tacho-enable">
                        <label for="tacho-enable"><b>Aktifkan Feedback (H(s))</b></label>
                    </div>
                    <div class="slider-container hidden" id="tacho-params">
                        <label for="kt">Tacho Gain ($K_t$): 
                            <span class="value-display" id="kt-val">0.1</span>
                        </label>
                        <input type="range" id="kt" min="0.0" max="2.0" value="0.1" step="0.05">
                    </div>
                    <p id="tacho-desc" style="font-size: 0.9em; color: var(--color-text-dim);">
                        (Feedback $H(s)=1$ (Unity))
                    </p>
                </div>

            </details>
        </div>
        
        <div class="simulation-panel">
            
            <div class="theory-box">
                <h2>Teori Dasar Simulator</h2>
                <p>
                    Simulator ini memodelkan respon sistem kendali motor DC terhadap masukan <strong>Unit Step</strong> (Setpoint = 1.0).
                </p>
                <ul>
                    <li><strong>Input (R(s)):</strong> Referensi/Setpoint yang diinginkan (nilai 1.0).</li>
                    <li><strong>Kendali (C(s)):</strong> Kontroler PID: $C(s) = K_p + K_i/s + K_d s$.</li>
                    <li><strong>Proses (G_p(s)):</strong> Plant motor DC (Orde 1 atau 2).</li>
                    <li><strong>Feedback (H(s)):</strong> Sensor. Bisa $H(s)=1$ (Unity, misal Encoder posisi) atau $H(s)=K_t$ / $H(s)=K_t s$ (Tachometer kecepatan).</li>
                    <li><strong>Output (Y(s)):</strong> Respon aktual (posisi/kecepatan).</li>
                </ul>
            </div>

            <h2>Respon Sistem (Step Input)</h2>
            <div id="plot-container"></div>

            <div class="tf-display-box">
                <h3>Fungsi Alih Sistem (Closed Loop)</h3>
                <div id="cl-tf-display" style="font-size: 1.2em;">
                    $$ G_{CL}(s) = \frac{C(s)G_p(s)}{1 + C(s)G_p(s)H(s)} = \text{...} $$
                </div>
                
                <div class="analysis-box">
                    <h3>Analisis Kuantitatif Sistem</h3>
                    <div id="cl-analysis-text"></div>
                    <div id="cl-poles-analysis"></div>
                </div>
            </div>

            <!-- Panel Interpretasi -->
            <details open class="interpretation-box">
                <summary style="color: var(--color-warning);">Analisis Lanjutan & Interpretasi</summary>
                <div id="interpretation-content">
                    <h3>Interpretasi Respon Transien</h3>
                    <div id="transient-interpretation"></div>
                    <br>
                    <h3>Interpretasi Stabilitas & Karakteristik Sistem</h3>
                    <div id="stability-interpretation"></div>
                </div>
            </details>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // ==========================================================
            // Variabel Global & Referensi Elemen DOM
            // ==========================================================
            
            const plantTypeSelect = document.getElementById('plant-type');
            
            const paramsKtau = document.getElementById('params-k-tau');
            const paramsZetaWn = document.getElementById('params-zeta-wn');
            
            const kSlider = document.getElementById('k');
            const tauSlider = document.getElementById('tau');
            const kOrd2Slider = document.getElementById('k_ord2');
            const zetaSlider = document.getElementById('zeta');
            const omegaNSlider = document.getElementById('omega_n');
            
            const pidEnableCheckbox = document.getElementById('pid-enable');
            const pidParamsContainer = document.getElementById('pid-params');
            const kpSlider = document.getElementById('kp');
            const kiSlider = document.getElementById('ki');
            const kdSlider = document.getElementById('kd');
            
            const tachoEnableCheckbox = document.getElementById('tacho-enable');
            const tachoParamsContainer = document.getElementById('tacho-params');
            const ktSlider = document.getElementById('kt');
            const tachoDesc = document.getElementById('tacho-desc');

            const clTfDisplay = document.getElementById('cl-tf-display');
            const clAnalysisText = document.getElementById('cl-analysis-text');
            const clPolesAnalysis = document.getElementById('cl-poles-analysis');
            
            const plotContainer = document.getElementById('plot-container');
            
            // Referensi elemen interpretasi
            const transientInterpretationDiv = document.getElementById('transient-interpretation');
            const stabilityInterpretationDiv = document.getElementById('stability-interpretation');

            // Konstanta Simulasi
            const T_SIM_MAX = 10.0;
            const DT = 0.005;
            const N_POINTS = Math.floor(T_SIM_MAX / DT);
            
            // ==========================================================
            // Kelas Helper: Polinomial dan Transfer Function (TF)
            // ==========================================================
            class Polynomial {
                constructor(coeffs) {
                    this.coeffs = coeffs.map(c => c || 0);
                }
                
                static multiply(p1, p2) {
                    const d1 = p1.coeffs.length - 1;
                    const d2 = p2.coeffs.length - 1;
                    const result = new Array(d1 + d2 + 1).fill(0);
                    for (let i = 0; i <= d1; i++) {
                        for (let j = 0; j <= d2; j++) {
                            result[i + j] += p1.coeffs[i] * p2.coeffs[j];
                        }
                    }
                    return new Polynomial(result);
                }
                
                static add(p1, p2) {
                    const d1 = p1.coeffs.length;
                    const d2 = p2.coeffs.length;
                    const maxLen = Math.max(d1, d2);
                    const result = new Array(maxLen).fill(0);
                    for (let i = 0; i < maxLen; i++) {
                        const c1 = p1.coeffs[d1 - 1 - i] || 0;
                        const c2 = p2.coeffs[d2 - 1 - i] || 0;
                        result[maxLen - 1 - i] = c1 + c2;
                    }
                    return new Polynomial(result);
                }

                toLatexString() {
                    let s = "";
                    const degree = this.coeffs.length - 1;
                    for (let i = 0; i <= degree; i++) {
                        const coeff = this.coeffs[i];
                        if (Math.abs(coeff) < 1e-9) continue;
                        
                        const power = degree - i;
                        const absCoeff = Math.abs(coeff);
                        const sign = coeff > 0 ? (i > 0 && s !== "" ? " + " : "") : " - ";
                        
                        s += sign;
                        
                        if (absCoeff.toFixed(4) !== '1.0000' || power === 0) {
                            s += absCoeff.toFixed(4).replace(/\.?0+$/, '');
                        }
                        
                        if (power > 0) {
                            s += "s";
                            if (power > 1) s += `^{${power}}`;
                        }
                    }
                    return s || "0";
                }
            }
            
            class TransferFunction {
                constructor(num, den) {
                    this.num = num;
                    this.den = den;
                }
                
                toLatexString(name = "G(s)") {
                    return `$$ ${name} = \\frac{${this.num.toLatexString()}}{${this.den.toLatexString()}} $$`;
                }
            }

            // ==========================================================
            // Fungsi Event Listener & Inisialisasi Utama
            // ==========================================================

            const allControls = document.querySelectorAll('input, select');
            allControls.forEach(control => control.addEventListener('input', updateSimulator));

            const computedStyles = getComputedStyle(document.documentElement);
            const colorText = computedStyles.getPropertyValue('--color-text').trim();
            const colorPrimary = computedStyles.getPropertyValue('--color-primary').trim();
            const colorSecondary = computedStyles.getPropertyValue('--color-secondary').trim();
            const colorDanger = computedStyles.getPropertyValue('--color-danger').trim();

            const plotlyLayout = {
                title: 'Respon Sistem terhadap Unit Step Input',
                xaxis: { title: 'Waktu (detik)', gridcolor: 'rgba(255,255,255,0.1)', zerolinecolor: colorPrimary },
                yaxis: { title: 'Amplitudo', gridcolor: 'rgba(255,255,255,0.1)', zerolinecolor: 'rgba(255,255,255,0.1)'},
                plot_bgcolor: 'transparent',
                paper_bgcolor: 'transparent',
                font: { color: colorText },
                legend: { x: 0.5, y: -0.2, orientation: 'h', xanchor: 'center' },
                margin: { l: 60, r: 30, b: 60, t: 80 }
            };

            initPlot();
            updateSimulator();

            // ==========================================================
            // Fungsi Update Utama
            // ==========================================================

            function updateSimulator() {
                const params = getParameters();
                updateUIState(params);
                const tfs = calculateTransferFunctions(params);
                updateTfDisplays(tfs);
                const simulationData = runSimulation(tfs.closedLoop);
                drawPlot(simulationData, params);
                updateAnalysis(tfs.closedLoop, simulationData, params);
            }
            
            // ==========================================================
            // Bagian 1: Pengambilan & Update UI
            // ==========================================================
            function getParameters() {
                return {
                    plantType: plantTypeSelect.value,
                    k: parseFloat(kSlider.value),
                    tau: parseFloat(tauSlider.value),
                    k_ord2: parseFloat(kOrd2Slider.value),
                    zeta: parseFloat(zetaSlider.value),
                    omega_n: parseFloat(omegaNSlider.value),
                    pidEnabled: pidEnableCheckbox.checked,
                    kp: parseFloat(kpSlider.value),
                    ki: parseFloat(kiSlider.value),
                    kd: parseFloat(kdSlider.value),
                    tachoEnabled: tachoEnableCheckbox.checked,
                    kt: parseFloat(ktSlider.value),
                };
            }
            
            function updateUIState(params) {
                document.getElementById('k-val').textContent = params.k.toFixed(2);
                document.getElementById('tau-val').textContent = params.tau.toFixed(2);
                document.getElementById('k_ord2-val').textContent = params.k_ord2.toFixed(2);
                document.getElementById('zeta-val').textContent = params.zeta.toFixed(2);
                document.getElementById('omega_n-val').textContent = params.omega_n.toFixed(2);
                document.getElementById('kp-val').textContent = params.kp.toFixed(2);
                document.getElementById('ki-val').textContent = params.ki.toFixed(2);
                document.getElementById('kd-val').textContent = params.kd.toFixed(2);
                document.getElementById('kt-val').textContent = params.kt.toFixed(2);
                
                const isType3 = params.plantType === "3";
                paramsKtau.classList.toggle('hidden', isType3);
                paramsZetaWn.classList.toggle('hidden', !isType3);
                
                pidParamsContainer.classList.toggle('hidden', !params.pidEnabled);
                tachoParamsContainer.classList.toggle('hidden', !params.tachoEnabled);
                
                let tachoHtml = "";
                if (params.tachoEnabled) {
                    if (params.plantType === "2") {
                        tachoHtml = `(Feedback Kecepatan $H(s) = K_t s = ${params.kt.toFixed(2)}s$)`;
                    } else {
                        tachoHtml = `(Feedback Proporsional $H(s) = K_t = ${params.kt.toFixed(2)}$)`;
                    }
                } else {
                    tachoHtml = "(Unity Feedback $H(s) = 1$)";
                }
                tachoDesc.innerHTML = tachoHtml;
            }
            
            // ==========================================================
            // Bagian 2: Kalkulasi Matematika
            // ==========================================================
            
            function calculateTransferFunctions(params) {
                let Gp, C, H;

                if (params.plantType === "1") {
                    Gp = new TransferFunction(new Polynomial([params.k]), new Polynomial([params.tau, 1]));
                } else if (params.plantType === "2") {
                    Gp = new TransferFunction(new Polynomial([params.k]), new Polynomial([params.tau, 1, 0]));
                } else {
                    const { k_ord2: k, omega_n: wn, zeta: z } = params;
                    Gp = new TransferFunction(new Polynomial([k * wn * wn]), new Polynomial([1, 2 * z * wn, wn * wn]));
                }
                
                C = params.pidEnabled ? new TransferFunction(new Polynomial([params.kd, params.kp, params.ki]), new Polynomial([1, 0])) : new TransferFunction(new Polynomial([1]), new Polynomial([1]));
                
                if (params.tachoEnabled) {
                    H = (params.plantType === "2") ? new TransferFunction(new Polynomial([params.kt, 0]), new Polynomial([1])) : new TransferFunction(new Polynomial([params.kt]), new Polynomial([1]));
                } else {
                    H = new TransferFunction(new Polynomial([1]), new Polynomial([1]));
                }
                
                const Num_CGp = Polynomial.multiply(C.num, Gp.num);
                const Den_CGp = Polynomial.multiply(C.den, Gp.den);
                
                const Num_CL = Polynomial.multiply(Num_CGp, H.den);
                const Den_CL = Polynomial.add(Polynomial.multiply(Den_CGp, H.den), Polynomial.multiply(Num_CGp, H.num));
                
                return { plant: Gp, closedLoop: new TransferFunction(Num_CL, Den_CL) };
            }
            
            function updateTfDisplays(tfs) {
                clTfDisplay.innerHTML = tfs.closedLoop.toLatexString("G_{CL}(s)");
                if (window.MathJax && window.MathJax.typeset) {
                    MathJax.typeset([clTfDisplay, tachoDesc]);
                }
            }

            // ==========================================================
            // Bagian 3: Simulasi & Plotting
            // ==========================================================
            
            function runSimulation(tf) {
                return simulateTF(tf);
            }
            
            function simulateTF(tf) {
                let b_coeffs = [...tf.num.coeffs].reverse();
                let a_coeffs = [...tf.den.coeffs].reverse();
                
                const n = a_coeffs.length - 1;
                const m = b_coeffs.length - 1;
                
                const time = new Array(N_POINTS);
                const response = new Array(N_POINTS);
                const input = 1.0;
                
                const a_n = a_coeffs[n];
                if (Math.abs(a_n) < 1e-9) {
                    return { time: Array(N_POINTS).fill(0).map((_,i) => i*DT), response: Array(N_POINTS).fill(NaN) };
                }

                const a = a_coeffs.map(c => c / a_n);
                const b = b_coeffs.map(c => c / a_n);
                
                for (let i = m + 1; i <= n; i++) b[i] = 0;
                
                if (n === 0) {
                    const gain = b[0] / a[0];
                    for (let i = 0; i < N_POINTS; i++) {
                        time[i] = i * DT;
                        response[i] = gain * input;
                    }
                    return { time, response };
                }

                const state = new Array(n).fill(0.0);
                
                for (let i = 0; i < N_POINTS; i++) {
                    time[i] = i * DT;
                    
                    let output_y = b.reduce((sum, bi, j) => sum + (j < n ? bi * state[j] : 0), 0) + b[n] * input;
                    response[i] = output_y;
                    
                    const state_dot = new Array(n).fill(0.0);
                    for (let j = 0; j < n - 1; j++) state_dot[j] = state[j+1];
                    
                    let x_n_dot = input - a.reduce((sum, ai, j) => sum + (j < n ? ai * state[j] : 0), 0);
                    state_dot[n-1] = x_n_dot;
                    
                    for (let j = 0; j < n; j++) state[j] += state_dot[j] * DT;
                }
                
                return { time, response };
            }

            function initPlot() {
                Plotly.newPlot(plotContainer, [], plotlyLayout, {responsive: true});
            }
            
            function drawPlot(data) {
                Plotly.react(plotContainer, [
                    { x: data.time, y: data.response, mode: 'lines', name: 'Respon Sistem (Closed Loop)', line: { color: colorDanger, width: 3 } },
                    { x: [0, T_SIM_MAX], y: [1.0, 1.0], mode: 'lines', name: 'Setpoint (Input)', line: { color: colorSecondary, dash: 'dash', width: 2 } }
                ], plotlyLayout);
            }

            // ==========================================================
            // Bagian 4: Analisis & Interpretasi
            // ==========================================================
            
            function updateAnalysis(closedLoopTf, data, params) {
                // Analisis Kuantitatif
                const statsCL = calculateResponseStats(data.response, data.time, 1.0);
                clAnalysisText.innerHTML = formatAnalysisHTML(statsCL);

                const poles = findPolynomialRoots(closedLoopTf.den.coeffs);
                clPolesAnalysis.innerHTML = formatPolesHTML(poles);
                
                // Analisis Kualitatif (Interpretasi)
                transientInterpretationDiv.innerHTML = generateTransientInterpretation(statsCL, params);
                stabilityInterpretationDiv.innerHTML = generateStabilityInterpretation(poles);
            }
            
            function formatAnalysisHTML(stats) {
                return `
                    <table>
                        <tr><th>Overshoot Maksimum (M<sub>p</sub>)</th><td>${stats.mp.toFixed(2)} %</td></tr>
                        <tr><th>Waktu Puncak (T<sub>p</sub>)</th><td>${stats.tp.toFixed(3)} s</td></tr>
                        <tr><th>Waktu Naik (T<sub>r</sub> 10-90%)</th><td>${stats.tr.toFixed(3)} s</td></tr>
                        <tr><th>Waktu Tunak (T<sub>s</sub> 2%)</th><td>${stats.ts.toFixed(3)} s</td></tr>
                        <tr><th>Nilai Akhir (Y<sub>ss</sub>)</th><td>${stats.yss.toFixed(3)}</td></tr>
                        <tr><th>Error Steady State (e<sub>ss</sub>)</th><td>${stats.ess.toFixed(3)}</td></tr>
                    </table>
                `;
            }

            function calculateResponseStats(response, time, setpoint) {
                if (isNaN(response[response.length - 1])) {
                    return { mp: 0, tp: 0, tr: 0, ts: T_SIM_MAX, yss: NaN, ess: NaN };
                }

                const y_final = response[response.length - 1];
                let y_max = y_final > 0 ? y_final : 0;
                let t_peak = 0, t_tr_10 = -1, t_tr_90 = -1, t_ts = T_SIM_MAX;
                
                const ts_band_upper = y_final * 1.02;
                const ts_band_lower = y_final * 0.98;
                
                for (let i = response.length - 1; i >= 0; i--) {
                    if (response[i] > ts_band_upper || response[i] < ts_band_lower) {
                        t_ts = (i + 1 < response.length) ? time[i+1] : T_SIM_MAX;
                        break;
                    }
                    if (i === 0) t_ts = time[0];
                }
                
                response.forEach((y, i) => {
                    if (y > y_max) { y_max = y; t_peak = time[i]; }
                    if (t_tr_10 === -1 && y >= y_final * 0.1) t_tr_10 = time[i];
                    if (t_tr_90 === -1 && y >= y_final * 0.9) t_tr_90 = time[i];
                });
                
                const mp = (y_max > y_final && Math.abs(y_final) > 1e-6) ? ((y_max - y_final) / y_final) * 100 : 0;
                const tr = (t_tr_10 !== -1 && t_tr_90 !== -1) ? (t_tr_90 - t_tr_10) : 0;
                const ess = setpoint - y_final;
                
                return { mp, tp: mp > 0 ? t_peak : 0, tr, ts: t_ts, yss: y_final, ess };
            }

            function findPolynomialRoots(coeffs) {
                let firstNonZero = coeffs.findIndex(c => Math.abs(c) > 1e-9);
                if (firstNonZero === -1) return [];
                let p = coeffs.slice(firstNonZero);
                const degree = p.length - 1;

                if (degree === 1) { return [{ re: -p[1] / p[0], im: 0 }]; }
                if (degree === 2) {
                    const [a, b, c] = p;
                    const d = b * b - 4 * a * c;
                    return d >= 0 ? [ { re: (-b + Math.sqrt(d)) / (2 * a), im: 0 }, { re: (-b - Math.sqrt(d)) / (2 * a), im: 0 } ] : [ { re: -b / (2 * a), im: Math.sqrt(-d) / (2 * a) }, { re: -b / (2 * a), im: -Math.sqrt(-d) / (2 * a) } ];
                }
                if (degree === 3) {
                    let [a, b, c, d] = p;
                    b /= a; c /= a; d /= a;
                    const p_ = (3 * c - b * b) / 3;
                    const q_ = (2 * Math.pow(b, 3) - 9 * b * c + 27 * d) / 27;
                    const D = Math.pow(q_ / 2, 2) + Math.pow(p_ / 3, 3);
                    const roots = [];
                    if (D >= 0) {
                        const u = Math.cbrt(-q_/2 + Math.sqrt(D)), v = Math.cbrt(-q_/2 - Math.sqrt(D));
                        roots.push({ re: u + v - b/3, im: 0 }, { re: -0.5*(u+v) - b/3, im: 0.5*Math.sqrt(3)*(u-v) }, { re: -0.5*(u+v) - b/3, im: -0.5*Math.sqrt(3)*(u-v) });
                    } else {
                        const r = Math.sqrt(-(Math.pow(p_/3, 3))), phi = Math.atan2(Math.sqrt(-D), -q_/2), R = 2 * Math.cbrt(r);
                        roots.push({ re: R * Math.cos(phi/3) - b/3, im: 0 }, { re: R * Math.cos((phi + 2*Math.PI)/3) - b/3, im: 0 }, { re: R * Math.cos((phi + 4*Math.PI)/3) - b/3, im: 0 });
                    }
                    return roots.map(r => ({ re: r.re, im: Math.abs(r.im) < 1e-9 ? 0 : r.im }));
                }
                return []; 
            }

            function formatPolesHTML(poles) {
                if (poles.length === 0) { return `<br><h3>Stabilitas & Pole Sistem</h3><p class="desc">Pole tidak dapat dihitung (sistem orde > 3).</p>`; }
                let polesHTML = '<ul>';
                let isStable = true;
                poles.forEach(pole => {
                    polesHTML += `<li>p = ${pole.re.toFixed(4)}`;
                    if (Math.abs(pole.im) > 1e-9) polesHTML += ` ${pole.im > 0 ? '+' : '-'} j${Math.abs(pole.im).toFixed(4)}`;
                    polesHTML += '</li>';
                    if (pole.re > 1e-6) isStable = false;
                });
                polesHTML += '</ul>';
                let stabilityDesc = isStable ? `<span class="good">STABIL</span>` : `<span class="bad">TIDAK STABIL</span>`;
                return `<br><h3>Stabilitas & Pole Sistem</h3>${polesHTML}<p class="desc">Kesimpulan: Sistem ini <strong>${stabilityDesc}</strong>.</p>`;
            }
            
            // ==========================================================
            // Bagian 5: Fungsi-Fungsi Interpretasi
            // ==========================================================

            function generateTransientInterpretation(stats, params) {
                let html = "";

                // Interpretasi Overshoot (Mp)
                if (stats.mp > 40) {
                    html += `<p><strong class="bad">Overshoot sangat tinggi (${stats.mp.toFixed(1)}%).</strong> Ini menunjukkan respons yang sangat agresif dan berisiko. Pada sistem nyata, ini bisa menyebabkan kerusakan mekanis (misal, lengan robot menabrak) atau ketidaknyamanan (misal, lift yang "terlontar"). Coba naikkan gain Derivatif (<code>Kd</code>) atau turunkan gain Proporsional (<code>Kp</code>).</p>`;
                } else if (stats.mp > 15) {
                    html += `<p><strong class="warn">Overshoot cukup tinggi (${stats.mp.toFixed(1)}%).</strong> Sistem merespons cepat, namun melampaui setpoint secara signifikan sebelum stabil. Ini mungkin dapat diterima untuk beberapa aplikasi, namun tidak untuk yang memerlukan presisi tinggi. Penambahan gain Derivatif (<code>Kd</code>) dapat membantu meredamnya.</p>`;
                } else if (stats.mp > 0) {
                     html += `<p><strong class="good">Overshoot terkendali (${stats.mp.toFixed(1)}%).</strong> Sistem menunjukkan respons yang cepat dengan sedikit ayunan. Ini adalah trade-off yang baik antara kecepatan dan stabilitas untuk banyak aplikasi.</p>`;
                } else {
                    html += `<p><strong class="good">Tidak ada overshoot.</strong> Sistem sangat teredam, memberikan respons yang mulus tanpa melampaui setpoint. Namun, perhatikan Waktu Tunak (Ts); bisa jadi responsnya terlalu lambat.</p>`;
                }

                // Interpretasi Waktu Tunak (Ts)
                if (stats.ts >= T_SIM_MAX * 0.99) {
                     html += `<p><strong class="bad">Sistem sangat lambat atau tidak pernah tunak</strong> dalam waktu simulasi. Respons ini mungkin terlalu lamban untuk aplikasi praktis. Untuk mempercepat, coba naikkan gain Proporsional (<code>Kp</code>) secara perlahan.</p>`;
                } else if (stats.ts > 4) {
                    html += `<p><strong class="warn">Waktu tunak (${stats.ts.toFixed(2)}s) tergolong lambat.</strong> Sistem membutuhkan waktu yang cukup lama untuk menghilangkan error dan mencapai kondisi stabil. Ini bisa menjadi masalah pada proses yang memerlukan kecepatan tinggi.</p>`;
                } else {
                    html += `<p><strong class="good">Waktu tunak (${stats.ts.toFixed(2)}s) tergolong cepat.</strong> Sistem mampu mencapai dan mempertahankan setpoint dalam waktu yang singkat, menunjukkan kinerja yang efisien dan responsif.</p>`;
                }

                // Interpretasi Error Steady-State (ess)
                if (Math.abs(stats.ess) > 0.05) {
                    html += `<p><strong class="bad">Error steady-state signifikan (${stats.ess.toFixed(3)}).</strong> Sistem tidak mampu mencapai setpoint secara presisi. Ini adalah ciri khas sistem Tipe 0 (seperti kendali P pada plant Tipe 0) yang tidak dapat melacak input step tanpa error. Solusinya adalah dengan menambahkan gain Integral (<code>Ki</code>), yang akan mengubahnya menjadi sistem Tipe 1 dan mengeliminasi error ini.</p>`;
                } else if (Math.abs(stats.ess) > 1e-3) {
                     html += `<p><strong class="warn">Terdapat sedikit error steady-state (${stats.ess.toFixed(3)}).</strong> Kemungkinan besar karena keterbatasan presisi numerik atau gain Integral (<code>Ki</code>) yang terlalu kecil untuk sepenuhnya menghilangkan error dalam waktu singkat.</p>`;
                } else {
                     html += `<p><strong class="good">Error steady-state dapat diabaikan (${stats.ess.toFixed(3)}).</strong> Sistem berhasil mencapai setpoint dengan presisi sangat tinggi, kemungkinan besar berkat adanya aksi kendali Integral (<code>Ki</code> > 0).</p>`;
                }

                return html;
            }

            function generateStabilityInterpretation(poles) {
                 if (poles.length === 0) return `<p>Interpretasi tidak tersedia karena pole tidak dapat dihitung untuk sistem orde lebih tinggi dari 3.</p>`;

                let isUnstable = poles.some(p => p.re > 1e-6);
                if (isUnstable) {
                    return `<p><strong class="bad">Sistem TIDAK STABIL.</strong> Adanya pole di sisi kanan bidang-s (memiliki bagian riil positif) menyebabkan respons sistem tumbuh secara eksponensial tanpa batas. Pada sistem fisik, ini akan berujung pada saturasi aktuator atau kerusakan fatal. Ini adalah kondisi yang harus dihindari dalam desain sistem kendali. Turunkan gain <code>Kp</code> secara drastis atau perkenalkan feedback yang lebih kuat.</p>`;
                }

                let hasComplex = poles.some(p => Math.abs(p.im) > 1e-6);
                let hasRepeated = false;
                if (poles.length > 1) {
                    for(let i=0; i<poles.length; i++){
                        for(let j=i+1; j<poles.length; j++){
                           if(Math.abs(poles[i].re - poles[j].re) < 1e-4 && Math.abs(poles[i].im - poles[j].im) < 1e-4){
                               hasRepeated = true;
                               break;
                           } 
                        }
                        if(hasRepeated) break;
                    }
                }

                if (hasComplex) {
                    return `<p><strong class="warn">Sistem Underdamped (Teredam Kurang).</strong> Adanya pasangan pole kompleks konjugat menyebabkan respons sistem berosilasi sebelum mencapai kestabilan.
                        <ul>
                            <li>Bagian Riil (<code>&sigma; = ${poles.find(p=>p.im > 0).re.toFixed(3)}</code>) menentukan seberapa cepat osilasi diredam. Semakin ke kiri (lebih negatif), semakin cepat redamannya.</li>
                            <li>Bagian Imajiner (<code>&omega;d = ${poles.find(p=>p.im > 0).im.toFixed(3)}</code>) menentukan frekuensi osilasi. Semakin besar, semakin cepat osilasinya.</li>
                        </ul>
                        Ini adalah karakteristik umum pada sistem yang responsif. Contohnya adalah suspensi mobil sport yang sedikit memantul.</p>`;
                } else if (hasRepeated) {
                    return `<p><strong class="good">Sistem Critically Damped (Teredam Kritis).</strong> Adanya pole riil yang berulang (sama) menunjukkan bahwa sistem memberikan respons tercepat yang mungkin tanpa mengalami overshoot. Ini sering dianggap sebagai kondisi ideal dalam banyak aplikasi, seperti gerakan presisi pada sebuah plotter atau robot bedah.</p>`;
                } else {
                     return `<p><strong class="good">Sistem Overdamped (Teredam Lebih).</strong> Semua pole sistem bersifat riil dan berbeda. Hal ini menghasilkan respons yang lambat dan mulus, tanpa osilasi sama sekali. Meskipun sangat stabil, sistem mungkin terlalu lamban untuk beberapa aplikasi. Contohnya adalah pintu hidrolik yang menutup perlahan tanpa membanting.</p>`;
                }
            }

        });
    </script>
</body>
</html>
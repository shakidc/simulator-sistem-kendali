<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TM UNIMAL: Simulator Sistem Kendali Motor Listrik</title>
    <link rel="icon" type="image/png" href="logo.png">

    <!-- Pustaka eksternal -->
    <script src="https://cdn.plot.ly/plotly-2.29.1.min.js"></script>
    <script>
        // Konfigurasi MathJax untuk merender persamaan LaTeX
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

    <style>
        /* Skema Warna & Font (Dark Theme) */
        :root {
            --color-bg: #1e1e1e;
            --color-bg-panel: #2a2a2a;
            --color-container: #252526;
            --color-border: #4a4a4a;
            --color-text: #d4d4d4;
            --color-text-dim: #9e9e9e;
            --color-primary: #00aaff;
            --color-secondary: #00ffaa;
            --color-danger: #ff5577;
            --color-warning: #ffee88;
            --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-mono: 'Courier New', Courier, monospace;
        }
        
        body {
            font-family: var(--font-main);
            background-color: var(--color-bg);
            color: var(--color-text);
            line-height: 1.6;
            margin: 0;
            padding: 24px;
        }

        h1, h2, h3 {
            color: var(--color-primary);
            border-bottom: 2px solid var(--color-border);
            padding-bottom: 8px;
            margin-top: 20px;
        }
        
        h1 { text-align: center; }

        /* === CSS untuk Header Logo (Tambahan) === */
        .header-logo-container {
            display: flex;
            align-items: center; /* Vertikal tengah */
            gap: 16px; /* Jarak antara logo dan teks */
            background-color: var(--color-bg); /* Sedikit beda dari panel */
            padding: 16px;
            border-radius: 8px;
            border: 1px solid var(--color-border);
            margin-bottom: 20px;
        }
        .header-logo {
            width: 80px; /* Ukuran logo, bisa disesuaikan */
            height: auto;
            flex-shrink: 0; /* Agar logo tidak 'gepeng' */
        }
        .header-text {
            font-family: var(--font-main);
            font-weight: bold;
            font-size: 1.15em; /* Ukuran font judul */
            color: var(--color-primary);
            line-height: 1.3;
        }
        /* ========================================= */

        /* Layout Utama Grid */
        .main-container {
            display: grid;
            grid-template-columns: 420px 1fr;
            gap: 24px;
            max-width: 1800px;
            min-height: 90vh;
            margin: 20px auto;
            background-color: var(--color-container);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border: 1px solid var(--color-border);
            /* overflow: hidden; */
        }

        .controls-panel {
            padding: 24px;
            border-right: 1px solid var(--color-border);
            border-radius: 10px;
            background-color: var(--color-bg-panel);
            /* overflow-y: auto; */
            position: sticky;
            top: 20px; /* Jarak dari atas viewport saat "menempel" */
            align-self: start; /* Penting agar 'sticky' berfungsi di dalam Grid */
        }

        .simulation-panel {
            padding: 24px;
            overflow-y: auto;
        }

        /* Kontrol UI (Slider, Details, dll) */
        details {
            margin-bottom: 20px;
            background: var(--color-container);
            border: 1px solid var(--color-border);
            border-radius: 8px;
        }
        
        details[open] summary {
            border-bottom: 1px solid var(--color-border);
        }

        summary {
            font-weight: bold;
            font-size: 1.2em;
            color: var(--color-primary);
            padding: 12px;
            cursor: pointer;
            list-style: none; /* Hapus marker default */
        }
        
        summary::-webkit-details-marker { display: none; } /* Chrome */
        summary::marker { display: none; } /* Firefox */

        summary:before {
            content: '► ';
            color: var(--color-primary);
            margin-right: 8px;
            transition: transform 0.2s ease-in-out;
            display: inline-block;
        }
        
        details[open] summary:before {
            transform: rotate(90deg);
        }
        
        .control-group {
            padding: 16px;
        }

        .slider-container {
            margin-bottom: 15px;
        }

        .slider-container label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--color-text);
        }
        
        .slider-container label .symbol {
            font-style: italic;
            font-size: 1.1em;
            color: var(--color-secondary);
        }

        .slider-container input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--color-primary);
        }

        .slider-container .value-display {
            font-weight: bold;
            color: var(--color-primary);
            float: right;
        }
        
        select, input[type="checkbox"] {
            background-color: var(--color-bg-panel);
            color: var(--color-text);
            border: 1px solid var(--color-border);
            border-radius: 4px;
            padding: 5px;
            margin-right: 5px;
        }

        /* Tampilan Persamaan (TF) */
        .tf-display-box {
            background: #1a1a1a;
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .tf-display-box h3 {
            margin-top: 0;
        }

        /* Analisis */
        .analysis-box {
            background: var(--color-bg-panel);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .analysis-box h3 {
            margin-top: 0;
            color: var(--color-secondary);
        }
        
        .analysis-box table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .analysis-box th, .analysis-box td {
            border-bottom: 1px solid var(--color-border);
            padding: 8px;
            text-align: left;
        }
        
        .analysis-box th {
            color: var(--color-text-dim);
            font-size: 0.9em;
        }
        
        .analysis-box td {
            font-weight: bold;
            font-family: var(--font-mono);
            font-size: 1.1em;
        }

        .analysis-box ul {
            list-style: none;
            padding: 0;
        }
        .analysis-box li {
            font-family: var(--font-mono);
            font-size: 1.1em;
            background: #333;
            padding: 5px 10px;
            border-radius: 4px;
            margin-bottom: 5px;
        }
        
        .analysis-box .desc {
            font-size: 0.9em;
            color: var(--color-text-dim);
            margin-top: 15px;
            border-top: 1px dashed var(--color-border);
            padding-top: 10px;
        }

        /* Interpretation Box */
        .interpretation-box {
            background-color: #1c2a38;
            border: 1px solid var(--color-primary);
            border-left: 5px solid var(--color-primary);
            padding: 20px;
            border-radius: 8px;
            margin-top: 24px;
        }
        .interpretation-box h3 {
            color: var(--color-primary);
            margin-top: 0;
        }
        .interpretation-box p {
            margin-bottom: 15px;
        }
        .interpretation-box strong {
            color: var(--color-secondary);
        }
        .interpretation-box code {
            background-color: #333;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: var(--font-mono);
        }
        .interpretation-box .good { color: var(--color-secondary); }
        .interpretation-box .bad { color: var(--color-danger); }
        .interpretation-box .warn { color: var(--color-warning); }


        /* Plotly Container */
        #plot-container {
            width: 100%;
            height: 550px;
            border: 1px solid var(--color-border);
            border-radius: 8px;
        }

        /* Penjelasan Teori */
        .theory-box {
            background-color: #2c2c1d;
            border: 1px solid var(--color-warning);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 24px;
            color: #f0f0f0;
        }
        .theory-box h2 {
            color: var(--color-warning);
            margin-top: 0;
        }
        
        .hidden { display: none; }

        /* === CSS untuk Animasi (Tambahan) === */
        #motor-animation-canvas {
            background-color: #1a1a1a;
            border-radius: 8px;
            border: 1px solid var(--color-border);
        }
        /* ==================================== */

        /* === CSS untuk Footer (Tambahan) === */
        footer {
            text-align: center;
            padding: 24px;
            margin-top: 20px;
            color: var(--color-text-dim);
            font-size: 0.9em;
            border-top: 1px solid var(--color-border);
        }
    </style>
</head>
<body>

    <div class="main-container">
        
        <div class="controls-panel">
            <div class="header-logo-container">
            <img src="logo.png" alt="Logo UNIMAL" class="header-logo">
            <div class="header-text">
            <div>SIMULATOR</div>
            <div>SISTEM KENDALI</div>
            <div>MOTOR LISTRIK</div>
            </div>
        </div>

            <details open>
                <summary>1. Sistem Plant (Motor)</summary>
                <div class="control-group">
                    <label for="plant-type" style="font-weight: bold;">Pilih Model Plant Motor:</label>
                    <select id="plant-type" style="width: 100%;">
                        <option value="1">a. Orde 1: Kendali Kecepatan (Induktansi La ≈ 0)</option>
                        <option value="2">b. Orde 2: Kendali Posisi (Motor Orde 1)</option>
                        <option value="3">c. Orde 2: Kendali Kecepatan (Induktansi La ≠ 0)</option>
                    </select>
                </div>
            </details>
            
            <details open>
                <summary>2. Parameter Plant (G_p(s))</summary>
                
                <div id="params-k-tau" class="control-group">
                    <div class="slider-container">
                        <label for="k">Gain (<span class="symbol">K</span>): 
                            <span class="value-display" id="k-val">2.0</span>
                        </label>
                        <input type="range" id="k" min="0.1" max="10.0" value="2.0" step="0.1">
                    </div>
                    <div class="slider-container">
                        <label for="tau">Konstanta Waktu (<span class="symbol">&tau;</span>): 
                            <span class="value-display" id="tau-val">0.5</span>
                        </label>
                        <input type="range" id="tau" min="0.1" max="5.0" value="0.5" step="0.1">
                    </div>
                </div>

                <div id="params-zeta-wn" class="control-group hidden">
                    <div class="slider-container">
                        <label for="k_ord2">Gain (<span class="symbol">K</span>): 
                            <span class="value-display" id="k_ord2-val">1.0</span>
                        </label>
                        <input type="range" id="k_ord2" min="0.1" max="10.0" value="1.0" step="0.1">
                    </div>
                    <div class="slider-container">
                        <label for="zeta">Rasio Redaman (<span class="symbol">&zeta;</span>): 
                            <span class="value-display" id="zeta-val">0.2</span>
                        </label>
                        <input type="range" id="zeta" min="0.0" max="2.0" value="0.2" step="0.05">
                    </div>
                    <div class="slider-container">
                        <label for="omega_n">Frekuensi Natural (<span class="symbol">&omega;<sub>n</sub></span>): 
                            <span class="value-display" id="omega_n-val">5.0</span>
                        </label>
                        <input type="range" id="omega_n" min="0.1" max="20.0" value="5.0" step="0.1">
                    </div>
                </div>
            </details>

            <details open>
                <summary>3. Konfigurasi Kendali (Loop)</summary>
                
                <div class="control-group">
                    <div>
                        <input type="checkbox" id="pid-enable">
                        <label for="pid-enable"><b>Aktifkan Kendali PID (C(s))</b></label>
                    </div>
                    <div class="slider-container hidden" id="pid-params">
                        <label for="kp">Proporsional ($K_p$): 
                            <span class="value-display" id="kp-val">1.0</span>
                        </label>
                        <input type="range" id="kp" min="0.0" max="20.0" value="1.0" step="0.1">
                        
                        <label for="ki">Integral ($K_i$): 
                            <span class="value-display" id="ki-val">0.5</span>
                        </label>
                        <input type="range" id="ki" min="0.0" max="10.0" value="0.5" step="0.1">
                        
                        <label for="kd">Derivatif ($K_d$): 
                            <span class="value-display" id="kd-val">0.1</span>
                        </label>
                        <input type="range" id="kd" min="0.0" max="10.0" value="0.1" step="0.1">
                    </div>
                </div>

                <div class="control-group">
                    <div>
                        <input type="checkbox" id="tacho-enable">
                        <label for="tacho-enable"><b>Aktifkan Feedback (H(s))</b></label>
                    </div>
                    <div class="slider-container hidden" id="tacho-params">
                        <label for="kt">Tacho Gain ($K_t$): 
                            <span class="value-display" id="kt-val">0.1</span>
                        </label>
                        <input type="range" id="kt" min="0.0" max="2.0" value="0.1" step="0.05">
                    </div>
                    <p id="tacho-desc" style="font-size: 0.9em; color: var(--color-text-dim);">
                        (Feedback $H(s)=1$ (Unity))
                    </p>
                </div>

            </details>
        </div>
        
        <div class="simulation-panel">
            
            <div class="theory-box">
                <h2>Teori Dasar Simulator</h2>
                <p>
                    Simulator ini memodelkan respon sistem kendali motor DC terhadap masukan <strong>Unit Step</strong> (Setpoint = 1.0).
                </p>
                <ul>
                    <li><strong>Input (R(s)):</strong> Referensi/Setpoint yang diinginkan (nilai 1.0).</li>
                    <li><strong>Kendali (C(s)):</strong> Kontroler PID: $C(s) = K_p + K_i/s + K_d s$.</li>
                    <li><strong>Proses (G_p(s)):</strong> Plant motor DC (Orde 1 atau 2).</li>
                    <li><strong>Feedback (H(s)):</strong> Sensor. Bisa $H(s)=1$ (Unity, misal Encoder posisi) atau $H(s)=K_t$ / $H(s)=K_t s$ (Tachometer kecepatan).</li>
                    <li><strong>Output (Y(s)):</strong> Respon aktual (posisi/kecepatan).</li>
                </ul>
            </div>
            <details class="theory-box" style="border-color: var(--color-primary); background-color: #1c2a38;">
                <summary style="font-size: 1.2em; color: var(--color-warning);">
                    Fungsi Alih dan Dasar Teori Motor DC Umum (Orde 2)
                </summary>
                <div style="padding-top: 15px;">
                    <details class="theory-box" style="border-color: var(--color-warning); background-color: #1c2a38;">
                    <summary style="font-size: 1.2em; color: var(--color-secondary);">
                    1. Analisis Sisi Listrik (Hukum Tegangan Kirchhoff)
                    </summary>
                    <p>Kita modelkan rangkaian jangkar sebagai resistor ($R_a$), induktor ($L_a$), dan sumber GGL Balik (<i>Back-EMF</i>, $V_b$).<br>Sesuai KVL, total tegangan $V_a$ adalah:</p>
                    $$ V_a(t) = R_a i_a(t) + L_a \frac{di_a(t)}{dt} + V_b(t) $$
                    <p>GGL Balik $V_b(t)$ sebanding dengan kecepatan putar $\omega(t)$:</p>
                    $$ V_b(t) = K_b \omega(t) $$
                    <p>Transformasi Laplace dari kedua persamaan (asumsi kondisi awal nol):</p>
                    $$ V_a(s) = (R_a + L_a s) I_a(s) + K_b \omega(s) $$
                    <p>Dari sini, kita dapatkan persamaan untuk arus $I_a(s)$:</p>
                    $$ I_a(s) = \frac{V_a(s) - K_b \omega(s)}{L_a s + R_a} \quad \text{(A)} $$
                    </details>
                    <details class="theory-box" style="border-color: var(--color-warning); background-color: #1c2a38;">
                    <summary style="font-size: 1.2em; color: var(--color-secondary);">
                    2. Analisis Sisi Mekanik (Hukum Newton II Rotasi)
                    </summary>
                    <p>Torsi yang dibangkitkan motor ($T_m$) digunakan untuk mengatasi inersia rotor ($J$) dan gesekan viskos ($B$).</p>
                    $$ \Sigma T = J \frac{d\omega(t)}{dt} \implies T_m(t) - T_{gesek}(t) = J \frac{d\omega(t)}{dt} $$
                    <p>Dengan torsi motor $T_m(t) = K_t i_a(t)$ dan gesekan $T_{gesek}(t) = B \omega(t)$, kita dapatkan:</p>
                    $$ K_t i_a(t) - B \omega(t) = J \frac{d\omega(t)}{dt} $$
                    <p>Transformasi Laplace dari persamaan ini:</p>
                    $$ K_t I_a(s) - B \omega(s) = J s \omega(s) $$
                    <p>Pindahkan semua $\omega(s)$ ke satu sisi untuk mendapatkan persamaan:</p>
                    $$ K_t I_a(s) = (J s + B) \omega(s) \quad \text{(B)} $$
                    </details>
                    <details class="theory-box" style="border-color: var(--color-warning); background-color: #1c2a38;">
                    <summary style="font-size: 1.2em; color: var(--color-secondary);">
                    3. Menggabungkan Sisi Listrik & Mekanik
                    </summary>
                    <p>Kita substitusikan Persamaan (A) ke dalam Persamaan (B) untuk mengeliminasi $I_a(s)$:</p>
                    $$ K_t \left( \frac{V_a(s) - K_b \omega(s)}{L_a s + R_a} \right) = (J s + B) \omega(s) $$
                    <p>Sekarang, kita selesaikan persamaan ini untuk mendapatkan $\frac{\omega(s)}{V_a(s)}$:</p>
                    $$ K_t V_a(s) - K_t K_b \omega(s) = (J s + B)(L_a s + R_a) \omega(s) $$
                    $$ K_t V_a(s) = \left[ (J s + B)(L_a s + R_a) + K_t K_b \right] \omega(s) $$
                    <p>Fungsi alih akhir (Orde 2) adalah:</p>
                    $$ G(s) = \frac{\omega(s)}{V_a(s)} = \frac{K_t}{(J s + B)(L_a s + R_a) + K_t K_b} $$
                    <p>Jika kita ekspansi penyebutnya, kita dapatkan bentuk polinomial orde 2:</p>
                    $$ G(s) = \frac{K_t}{L_a J s^2 + (R_a J + L_a B) s + (R_a B + K_t K_b)} $$
                    
                    <hr style="border-color: var(--color-border); margin: 20px 0;">
                    </details>
                    <details class="theory-box" style="border-color: var(--color-warning); background-color: #1c2a38;">
                    <summary style="font-size: 1.2em; color: var(--color-secondary);">
                    4. Penjelasan Parameter & Pengaruhnya
                    </summary>
                    <ul style="padding-left: 20px;">
                        <li><strong>Parameter Listrik:</strong>
                            <ul style="padding-left: 20px;">
                                <li>$R_a$ (Resistansi Jangkar): Menyebabkan kerugian daya (panas). <br><strong>Pengaruh:</strong> $R_a$ yang tinggi meningkatkan redaman listrik (membantu stabil) tetapi menurunkan efisiensi dan torsi.</li>
                                <li>$L_a$ (Induktansi Jangkar): Menahan perubahan arus yang cepat. <br><strong>Pengaruh:</strong> $L_a$ yang besar memperlambat respons listrik (menambah <strong>lag</strong>). Ini adalah parameter kunci yang membuat sistem menjadi Orde 2.</li>
                            </ul>
                        </li>
                        <li><strong>Parameter Mekanik:</strong>
                            <ul style="padding-left: 20px;">
                                <li>$J$ (Inersia Rotor): Keengganan rotor untuk berakselerasi. <br><strong>Pengaruh:</strong> $J$ yang besar membuat motor lambat merespons (konstanta waktu mekanik besar).</li>
                                <li>$B$ (Gesekan Viskos): Redaman mekanik (gesekan bearing). <br><strong>Pengaruh:</strong> $B$ yang besar menambah redaman sistem (membantu motor berhenti) tetapi butuh lebih banyak torsi.</li>
                            </ul>
                        </li>
                        <li><strong>Konstanta Elektromekanik:</strong>
                            <ul style="padding-left: 20px;">
                                <li>$K_t$ (Konstanta Torsi): Mengubah arus ($I_a$) menjadi torsi ($T_m$). <br><strong>Pengaruh:</strong> $K_t$ yang tinggi berarti motor "kuat" (torsi besar per Ampere).</li>
                                <li>$K_b$ (Konstanta GGL Balik): Mengubah kecepatan ($\omega$) menjadi tegangan GGL Balik ($V_b$). <br><strong>Pengaruh:</strong> $K_b$ yang tinggi secara alami membatasi kecepatan maksimum motor.</li>
                            </ul>
                        </li>
                    </ul>
                    </details>
                    <details class="theory-box" style="border-color: var(--color-warning); background-color: #1c2a38;">
                    <summary style="font-size: 1.2em; color: var(--color-secondary);">
                    5. Simplifikasi Menjadi Orde 1
                    </summary>
                    <p>Dalam banyak motor, induktansi $L_a$ sangat kecil sehingga bisa diabaikan ($L_a \approx 0$).<br>Jika $L_a = 0$, fungsi alih menjadi:</p>
                    $$ G(s) = \frac{K_t}{R_a (J s + B) + K_t K_b} = \frac{K_t}{R_a J s + (R_a B + K_t K_b)} $$
                    <p>Ini adalah bentuk standar sistem orde 1:</p> 
                        $$ G(s) = \frac{K}{\tau s + 1}$$
                    <p>Di mana:
                    <ul style="padding-left: 20px;">
                        <li>Gain $K = \frac{K_t}{R_a B + K_t K_b}$</li>
                        <li>Konstanta Waktu $\tau = \frac{R_a J}{R_a B + K_t K_b}$</li>
                    </ul>
                    </p>
                    </details>
                </div>
            </details>
            <details class="interpretation-box" style="border-color: var(--color-secondary);">
            <summary style="color: var(--color-secondary);">Visualisasi Animasi Motor</summary>
            <div style="text-align: center; padding: 10px;">
                <canvas id="motor-animation-canvas" width="400" height="250"></canvas>
                <div id="animation-status" style="color: var(--color-text-dim); font-style: italic; margin-top: 10px;">
                    Silakan ubah parameter untuk memulai simulasi...
                </div>
            </div>
            </details>
            
            <h2>Respon Sistem (Step Input)</h2>
            <div id="plot-container"></div>

            <div class="tf-display-box">
                <h3>Fungsi Alih Sistem (Closed Loop)</h3>
                <div id="cl-tf-display" style="font-size: 1.2em;">
                    $$ G_{CL}(s) = \frac{C(s)G_p(s)}{1 + C(s)G_p(s)H(s)} = \text{...} $$
                </div>
                
                <div class="analysis-box">
                    <h3>Analisis Kuantitatif Sistem</h3>
                    <div id="cl-analysis-text"></div>
                    <div id="cl-poles-analysis"></div>
                </div>
            </div>

            <!-- Panel Interpretasi -->
            <details class="interpretation-box">
                <summary style="color: var(--color-warning);">Analisis Lanjutan & Interpretasi</summary>
                <div id="interpretation-content">
                    <h3>Interpretasi Respon Transien</h3>
                    <div id="transient-interpretation"></div>
                    <br>
                    <h3>Interpretasi Stabilitas & Karakteristik Sistem</h3>
                    <div id="stability-interpretation"></div>
                </div>
            </details>
        </div>
    </div>
    <footer>
        <p>&copy;2025 ShakiDC - Jurusan Teknik Mesin UNIMAL</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // ==========================================================
            // Variabel Global & Referensi Elemen DOM
            // ==========================================================
            
            const plantTypeSelect = document.getElementById('plant-type');
            
            const paramsKtau = document.getElementById('params-k-tau');
            const paramsZetaWn = document.getElementById('params-zeta-wn');
            
            const kSlider = document.getElementById('k');
            const tauSlider = document.getElementById('tau');
            const kOrd2Slider = document.getElementById('k_ord2');
            const zetaSlider = document.getElementById('zeta');
            const omegaNSlider = document.getElementById('omega_n');
            
            const pidEnableCheckbox = document.getElementById('pid-enable');
            const pidParamsContainer = document.getElementById('pid-params');
            const kpSlider = document.getElementById('kp');
            const kiSlider = document.getElementById('ki');
            const kdSlider = document.getElementById('kd');
            
            const tachoEnableCheckbox = document.getElementById('tacho-enable');
            const tachoParamsContainer = document.getElementById('tacho-params');
            const ktSlider = document.getElementById('kt');
            const tachoDesc = document.getElementById('tacho-desc');

            const clTfDisplay = document.getElementById('cl-tf-display');
            const clAnalysisText = document.getElementById('cl-analysis-text');
            const clPolesAnalysis = document.getElementById('cl-poles-analysis');
            
            const plotContainer = document.getElementById('plot-container');
            
            // Referensi elemen interpretasi
            const transientInterpretationDiv = document.getElementById('transient-interpretation');
            const stabilityInterpretationDiv = document.getElementById('stability-interpretation');

            const computedStyles = getComputedStyle(document.documentElement);
            const colorText = computedStyles.getPropertyValue('--color-text').trim();
            const colorPrimary = computedStyles.getPropertyValue('--color-primary').trim();
            const colorSecondary = computedStyles.getPropertyValue('--color-secondary').trim();
            const colorDanger = computedStyles.getPropertyValue('--color-danger').trim();
            const fontMain = computedStyles.getPropertyValue('--font-main').trim();
            const fontMono = computedStyles.getPropertyValue('--font-mono').trim();
            const colorBorder = computedStyles.getPropertyValue('--color-border').trim();
            const colorTextDim = computedStyles.getPropertyValue('--color-text-dim').trim();
            const colorBgPanel = computedStyles.getPropertyValue('--color-bg-panel').trim();

            // Referensi & State untuk Animasi
            const motorCanvas = document.getElementById('motor-animation-canvas');
            const motorCtx = motorCanvas.getContext('2d');
            const animationStatus = document.getElementById('animation-status');

            let currentAnimationId = null; // Untuk membatalkan animasi yg sedang berjalan
            let animationData = { response: [], time: [] };
            let animationPlantType = '1';

            // Variabel untuk playback animasi
            let animStartTime = 0;
            const animPlaybackDuration = 3000; // Durasi playback animasi (3 detik)

            // Konstanta Simulasi
            const T_SIM_MAX = 10.0;
            const DT = 0.005;
            const N_POINTS = Math.floor(T_SIM_MAX / DT);
            
            // ==========================================================
            // Kelas Helper: Polinomial dan Transfer Function (TF)
            // ==========================================================
            class Polynomial {
                constructor(coeffs) {
                    this.coeffs = coeffs.map(c => c || 0);
                }
                
                static multiply(p1, p2) {
                    const d1 = p1.coeffs.length - 1;
                    const d2 = p2.coeffs.length - 1;
                    const result = new Array(d1 + d2 + 1).fill(0);
                    for (let i = 0; i <= d1; i++) {
                        for (let j = 0; j <= d2; j++) {
                            result[i + j] += p1.coeffs[i] * p2.coeffs[j];
                        }
                    }
                    return new Polynomial(result);
                }
                
                static add(p1, p2) {
                    const d1 = p1.coeffs.length;
                    const d2 = p2.coeffs.length;
                    const maxLen = Math.max(d1, d2);
                    const result = new Array(maxLen).fill(0);
                    for (let i = 0; i < maxLen; i++) {
                        const c1 = p1.coeffs[d1 - 1 - i] || 0;
                        const c2 = p2.coeffs[d2 - 1 - i] || 0;
                        result[maxLen - 1 - i] = c1 + c2;
                    }
                    return new Polynomial(result);
                }

                toLatexString() {
                    let s = "";
                    const degree = this.coeffs.length - 1;
                    for (let i = 0; i <= degree; i++) {
                        const coeff = this.coeffs[i];
                        if (Math.abs(coeff) < 1e-9) continue;
                        
                        const power = degree - i;
                        const absCoeff = Math.abs(coeff);
                        const sign = coeff > 0 ? (i > 0 && s !== "" ? " + " : "") : " - ";
                        
                        s += sign;
                        
                        if (absCoeff.toFixed(4) !== '1.0000' || power === 0) {
                            s += absCoeff.toFixed(4).replace(/\.?0+$/, '');
                        }
                        
                        if (power > 0) {
                            s += "s";
                            if (power > 1) s += `^{${power}}`;
                        }
                    }
                    return s || "0";
                }
            }
            
            class TransferFunction {
                constructor(num, den) {
                    this.num = num;
                    this.den = den;
                }
                
                toLatexString(name = "G(s)") {
                    return `$$ ${name} = \\frac{${this.num.toLatexString()}}{${this.den.toLatexString()}} $$`;
                }
            }

            // ==========================================================
            // Fungsi Event Listener & Inisialisasi Utama
            // ==========================================================

            const allControls = document.querySelectorAll('input, select');
            allControls.forEach(control => {
                if (control.type === 'range') {
                    // Untuk SLIDER (RANGE):
                    // 1. 'input' (saat diseret): Update semua KECUALI animasi
                    control.addEventListener('input', () => updateSimulator(false));
                    // 2. 'change' (saat dilepas): Update semua TERMASUK animasi
                    control.addEventListener('change', () => updateSimulator(true));
                } else {
                    // Untuk CHECKBOX / DROPDOWN:
                    // 'input' (saat di-klik): Update semua TERMASUK animasi
                    control.addEventListener('input', () => updateSimulator(true));
                }
            });

            const plotlyLayout = {
                title: 'Respon Sistem terhadap Unit Step Input',
                xaxis: { title: 'Waktu (detik)', gridcolor: 'rgba(255,255,255,0.1)', zerolinecolor: colorPrimary },
                yaxis: { title: 'Amplitudo', gridcolor: 'rgba(255,255,255,0.1)', zerolinecolor: 'rgba(255,255,255,0.1)'},
                plot_bgcolor: 'transparent',
                paper_bgcolor: 'transparent',
                font: { color: colorText },
                legend: { x: 0.5, y: -0.2, orientation: 'h', xanchor: 'center' },
                margin: { l: 60, r: 30, b: 60, t: 80 }
            };

            initPlot();
            updateSimulator();

            // ==========================================================
            // Fungsi Update Utama
            // ==========================================================

            function updateSimulator(runAnimation = true) {
                const params = getParameters();
                updateUIState(params);
                const tfs = calculateTransferFunctions(params);
                updateTfDisplays(tfs);
                const simulationData = runSimulation(tfs.closedLoop);
                drawPlot(simulationData, params);
                updateAnalysis(tfs.closedLoop, simulationData, params);
                // Panggil fungsi animasi (Tambahan)
                if (runAnimation) {
                    runMotorAnimation(simulationData, params.plantType);
                }
            }
            
            // ==========================================================
            // Bagian 1: Pengambilan & Update UI
            // ==========================================================
            function getParameters() {
                return {
                    plantType: plantTypeSelect.value,
                    k: parseFloat(kSlider.value),
                    tau: parseFloat(tauSlider.value),
                    k_ord2: parseFloat(kOrd2Slider.value),
                    zeta: parseFloat(zetaSlider.value),
                    omega_n: parseFloat(omegaNSlider.value),
                    pidEnabled: pidEnableCheckbox.checked,
                    kp: parseFloat(kpSlider.value),
                    ki: parseFloat(kiSlider.value),
                    kd: parseFloat(kdSlider.value),
                    tachoEnabled: tachoEnableCheckbox.checked,
                    kt: parseFloat(ktSlider.value),
                };
            }
            
            function updateUIState(params) {
                document.getElementById('k-val').textContent = params.k.toFixed(2);
                document.getElementById('tau-val').textContent = params.tau.toFixed(2);
                document.getElementById('k_ord2-val').textContent = params.k_ord2.toFixed(2);
                document.getElementById('zeta-val').textContent = params.zeta.toFixed(2);
                document.getElementById('omega_n-val').textContent = params.omega_n.toFixed(2);
                document.getElementById('kp-val').textContent = params.kp.toFixed(2);
                document.getElementById('ki-val').textContent = params.ki.toFixed(2);
                document.getElementById('kd-val').textContent = params.kd.toFixed(2);
                document.getElementById('kt-val').textContent = params.kt.toFixed(2);
                
                const isType3 = params.plantType === "3";
                paramsKtau.classList.toggle('hidden', isType3);
                paramsZetaWn.classList.toggle('hidden', !isType3);
                
                pidParamsContainer.classList.toggle('hidden', !params.pidEnabled);
                tachoParamsContainer.classList.toggle('hidden', !params.tachoEnabled);
                
                let tachoHtml = "";
                if (params.tachoEnabled) {
                    if (params.plantType === "2") {
                        tachoHtml = `(Feedback Kecepatan $H(s) = K_t s = ${params.kt.toFixed(2)}s$)`;
                    } else {
                        tachoHtml = `(Feedback Proporsional $H(s) = K_t = ${params.kt.toFixed(2)}$)`;
                    }
                } else {
                    tachoHtml = "(Unity Feedback $H(s) = 1$)";
                }
                tachoDesc.innerHTML = tachoHtml;
            }
            
            // ==========================================================
            // Bagian 2: Kalkulasi Matematika
            // ==========================================================
            
            function calculateTransferFunctions(params) {
                let Gp, C, H;

                if (params.plantType === "1") {
                    Gp = new TransferFunction(new Polynomial([params.k]), new Polynomial([params.tau, 1]));
                } else if (params.plantType === "2") {
                    Gp = new TransferFunction(new Polynomial([params.k]), new Polynomial([params.tau, 1, 0]));
                } else {
                    const { k_ord2: k, omega_n: wn, zeta: z } = params;
                    Gp = new TransferFunction(new Polynomial([k * wn * wn]), new Polynomial([1, 2 * z * wn, wn * wn]));
                }
                
                C = params.pidEnabled ? new TransferFunction(new Polynomial([params.kd, params.kp, params.ki]), new Polynomial([1, 0])) : new TransferFunction(new Polynomial([1]), new Polynomial([1]));
                
                if (params.tachoEnabled) {
                    H = (params.plantType === "2") ? new TransferFunction(new Polynomial([params.kt, 0]), new Polynomial([1])) : new TransferFunction(new Polynomial([params.kt]), new Polynomial([1]));
                } else {
                    H = new TransferFunction(new Polynomial([1]), new Polynomial([1]));
                }
                
                const Num_CGp = Polynomial.multiply(C.num, Gp.num);
                const Den_CGp = Polynomial.multiply(C.den, Gp.den);
                
                const Num_CL = Polynomial.multiply(Num_CGp, H.den);
                const Den_CL = Polynomial.add(Polynomial.multiply(Den_CGp, H.den), Polynomial.multiply(Num_CGp, H.num));
                
                return { plant: Gp, closedLoop: new TransferFunction(Num_CL, Den_CL) };
            }
            
            function updateTfDisplays(tfs) {
                clTfDisplay.innerHTML = tfs.closedLoop.toLatexString("G_{CL}(s)");
                if (window.MathJax && window.MathJax.typeset) {
                    MathJax.typeset([clTfDisplay, tachoDesc]);
                }
            }

            // ==========================================================
            // Bagian 3: Simulasi & Plotting
            // ==========================================================
            
            function runSimulation(tf) {
                return simulateTF(tf);
            }
            
            function simulateTF(tf) {
                let b_coeffs = [...tf.num.coeffs].reverse();
                let a_coeffs = [...tf.den.coeffs].reverse();
                
                const n = a_coeffs.length - 1;
                const m = b_coeffs.length - 1;
                
                const time = new Array(N_POINTS);
                const response = new Array(N_POINTS);
                const input = 1.0;
                
                const a_n = a_coeffs[n];
                if (Math.abs(a_n) < 1e-9) {
                    return { time: Array(N_POINTS).fill(0).map((_,i) => i*DT), response: Array(N_POINTS).fill(NaN) };
                }

                const a = a_coeffs.map(c => c / a_n);
                const b = b_coeffs.map(c => c / a_n);
                
                for (let i = m + 1; i <= n; i++) b[i] = 0;
                
                if (n === 0) {
                    const gain = b[0] / a[0];
                    for (let i = 0; i < N_POINTS; i++) {
                        time[i] = i * DT;
                        response[i] = gain * input;
                    }
                    return { time, response };
                }

                const state = new Array(n).fill(0.0);
                
                for (let i = 0; i < N_POINTS; i++) {
                    time[i] = i * DT;
                    
                    let output_y = b.reduce((sum, bi, j) => sum + (j < n ? bi * state[j] : 0), 0) + b[n] * input;
                    response[i] = output_y;
                    
                    const state_dot = new Array(n).fill(0.0);
                    for (let j = 0; j < n - 1; j++) state_dot[j] = state[j+1];
                    
                    let x_n_dot = input - a.reduce((sum, ai, j) => sum + (j < n ? ai * state[j] : 0), 0);
                    state_dot[n-1] = x_n_dot;
                    
                    for (let j = 0; j < n; j++) state[j] += state_dot[j] * DT;
                }
                
                return { time, response };
            }

            function initPlot() {
                Plotly.newPlot(plotContainer, [], plotlyLayout, {responsive: true});
            }
            
            function drawPlot(data) {
                Plotly.react(plotContainer, [
                    { x: data.time, y: data.response, mode: 'lines', name: 'Respon Sistem (Closed Loop)', line: { color: colorDanger, width: 3 } },
                    { x: [0, T_SIM_MAX], y: [1.0, 1.0], mode: 'lines', name: 'Setpoint (Input)', line: { color: colorSecondary, dash: 'dash', width: 2 } }
                ], plotlyLayout);
            }

            // ==========================================================
            // Bagian 4: Analisis & Interpretasi
            // ==========================================================
            
            function updateAnalysis(closedLoopTf, data, params) {
                // Analisis Kuantitatif
                const statsCL = calculateResponseStats(data.response, data.time, 1.0);
                clAnalysisText.innerHTML = formatAnalysisHTML(statsCL);

                const poles = findPolynomialRoots(closedLoopTf.den.coeffs);
                clPolesAnalysis.innerHTML = formatPolesHTML(poles);
                
                // Analisis Kualitatif (Interpretasi)
                transientInterpretationDiv.innerHTML = generateTransientInterpretation(statsCL, params);
                stabilityInterpretationDiv.innerHTML = generateStabilityInterpretation(poles);
            }
            
            function formatAnalysisHTML(stats) {
                return `
                    <table>
                        <tr><th>Overshoot Maksimum (M<sub>p</sub>)</th><td>${stats.mp.toFixed(2)} %</td></tr>
                        <tr><th>Waktu Puncak (T<sub>p</sub>)</th><td>${stats.tp.toFixed(3)} s</td></tr>
                        <tr><th>Waktu Naik (T<sub>r</sub> 10-90%)</th><td>${stats.tr.toFixed(3)} s</td></tr>
                        <tr><th>Waktu Tunak (T<sub>s</sub> 2%)</th><td>${stats.ts.toFixed(3)} s</td></tr>
                        <tr><th>Nilai Akhir (Y<sub>ss</sub>)</th><td>${stats.yss.toFixed(3)}</td></tr>
                        <tr><th>Error Steady State (e<sub>ss</sub>)</th><td>${stats.ess.toFixed(3)}</td></tr>
                    </table>
                `;
            }

            function calculateResponseStats(response, time, setpoint) {
                if (isNaN(response[response.length - 1])) {
                    return { mp: 0, tp: 0, tr: 0, ts: T_SIM_MAX, yss: NaN, ess: NaN };
                }

                const y_final = response[response.length - 1];
                let y_max = y_final > 0 ? y_final : 0;
                let t_peak = 0, t_tr_10 = -1, t_tr_90 = -1, t_ts = T_SIM_MAX;
                
                const ts_band_upper = y_final * 1.02;
                const ts_band_lower = y_final * 0.98;
                
                for (let i = response.length - 1; i >= 0; i--) {
                    if (response[i] > ts_band_upper || response[i] < ts_band_lower) {
                        t_ts = (i + 1 < response.length) ? time[i+1] : T_SIM_MAX;
                        break;
                    }
                    if (i === 0) t_ts = time[0];
                }
                
                response.forEach((y, i) => {
                    if (y > y_max) { y_max = y; t_peak = time[i]; }
                    if (t_tr_10 === -1 && y >= y_final * 0.1) t_tr_10 = time[i];
                    if (t_tr_90 === -1 && y >= y_final * 0.9) t_tr_90 = time[i];
                });
                
                const mp = (y_max > y_final && Math.abs(y_final) > 1e-6) ? ((y_max - y_final) / y_final) * 100 : 0;
                const tr = (t_tr_10 !== -1 && t_tr_90 !== -1) ? (t_tr_90 - t_tr_10) : 0;
                const ess = setpoint - y_final;
                
                return { mp, tp: mp > 0 ? t_peak : 0, tr, ts: t_ts, yss: y_final, ess };
            }

            function findPolynomialRoots(coeffs) {
                let firstNonZero = coeffs.findIndex(c => Math.abs(c) > 1e-9);
                if (firstNonZero === -1) return [];
                let p = coeffs.slice(firstNonZero);
                const degree = p.length - 1;

                if (degree === 1) { return [{ re: -p[1] / p[0], im: 0 }]; }
                if (degree === 2) {
                    const [a, b, c] = p;
                    const d = b * b - 4 * a * c;
                    return d >= 0 ? [ { re: (-b + Math.sqrt(d)) / (2 * a), im: 0 }, { re: (-b - Math.sqrt(d)) / (2 * a), im: 0 } ] : [ { re: -b / (2 * a), im: Math.sqrt(-d) / (2 * a) }, { re: -b / (2 * a), im: -Math.sqrt(-d) / (2 * a) } ];
                }
                if (degree === 3) {
                    let [a, b, c, d] = p;
                    b /= a; c /= a; d /= a;
                    const p_ = (3 * c - b * b) / 3;
                    const q_ = (2 * Math.pow(b, 3) - 9 * b * c + 27 * d) / 27;
                    const D = Math.pow(q_ / 2, 2) + Math.pow(p_ / 3, 3);
                    const roots = [];
                    if (D >= 0) {
                        const u = Math.cbrt(-q_/2 + Math.sqrt(D)), v = Math.cbrt(-q_/2 - Math.sqrt(D));
                        roots.push({ re: u + v - b/3, im: 0 }, { re: -0.5*(u+v) - b/3, im: 0.5*Math.sqrt(3)*(u-v) }, { re: -0.5*(u+v) - b/3, im: -0.5*Math.sqrt(3)*(u-v) });
                    } else {
                        const r = Math.sqrt(-(Math.pow(p_/3, 3))), phi = Math.atan2(Math.sqrt(-D), -q_/2), R = 2 * Math.cbrt(r);
                        roots.push({ re: R * Math.cos(phi/3) - b/3, im: 0 }, { re: R * Math.cos((phi + 2*Math.PI)/3) - b/3, im: 0 }, { re: R * Math.cos((phi + 4*Math.PI)/3) - b/3, im: 0 });
                    }
                    return roots.map(r => ({ re: r.re, im: Math.abs(r.im) < 1e-9 ? 0 : r.im }));
                }
                return []; 
            }

            function formatPolesHTML(poles) {
                if (poles.length === 0) { return `<br><h3>Stabilitas & Pole Sistem</h3><p class="desc">Pole tidak dapat dihitung (sistem orde > 3).</p>`; }
                let polesHTML = '<ul>';
                let isStable = true;
                poles.forEach(pole => {
                    polesHTML += `<li>p = ${pole.re.toFixed(4)}`;
                    if (Math.abs(pole.im) > 1e-9) polesHTML += ` ${pole.im > 0 ? '+' : '-'} j${Math.abs(pole.im).toFixed(4)}`;
                    polesHTML += '</li>';
                    if (pole.re > 1e-6) isStable = false;
                });
                polesHTML += '</ul>';
                let stabilityDesc = isStable ? `<span class="good">STABIL</span>` : `<span class="bad">TIDAK STABIL</span>`;
                return `<br><h3>Stabilitas & Pole Sistem</h3>${polesHTML}<p class="desc">Kesimpulan: Sistem ini <strong>${stabilityDesc}</strong>.</p>`;
            }
            
            // ==========================================================
            // Bagian 5: Fungsi-Fungsi Interpretasi
            // ==========================================================

            function generateTransientInterpretation(stats, params) {
                let html = "";

                // Interpretasi Overshoot (Mp)
                if (stats.mp > 40) {
                    html += `<p><strong class="bad">Overshoot sangat tinggi (${stats.mp.toFixed(1)}%).</strong> Ini menunjukkan respons yang sangat agresif dan berisiko. Pada sistem nyata, ini bisa menyebabkan kerusakan mekanis (misal, lengan robot menabrak) atau ketidaknyamanan (misal, lift yang "terlontar"). Coba naikkan gain Derivatif (<code>Kd</code>) atau turunkan gain Proporsional (<code>Kp</code>).</p>`;
                } else if (stats.mp > 15) {
                    html += `<p><strong class="warn">Overshoot cukup tinggi (${stats.mp.toFixed(1)}%).</strong> Sistem merespons cepat, namun melampaui setpoint secara signifikan sebelum stabil. Ini mungkin dapat diterima untuk beberapa aplikasi, namun tidak untuk yang memerlukan presisi tinggi. Penambahan gain Derivatif (<code>Kd</code>) dapat membantu meredamnya.</p>`;
                } else if (stats.mp > 0) {
                     html += `<p><strong class="good">Overshoot terkendali (${stats.mp.toFixed(1)}%).</strong> Sistem menunjukkan respons yang cepat dengan sedikit ayunan. Ini adalah trade-off yang baik antara kecepatan dan stabilitas untuk banyak aplikasi.</p>`;
                } else {
                    html += `<p><strong class="good">Tidak ada overshoot.</strong> Sistem sangat teredam, memberikan respons yang mulus tanpa melampaui setpoint. Namun, perhatikan Waktu Tunak (Ts); bisa jadi responsnya terlalu lambat.</p>`;
                }

                // Interpretasi Waktu Tunak (Ts)
                if (stats.ts >= T_SIM_MAX * 0.99) {
                     html += `<p><strong class="bad">Sistem sangat lambat atau tidak pernah tunak</strong> dalam waktu simulasi. Respons ini mungkin terlalu lamban untuk aplikasi praktis. Untuk mempercepat, coba naikkan gain Proporsional (<code>Kp</code>) secara perlahan.</p>`;
                } else if (stats.ts > 4) {
                    html += `<p><strong class="warn">Waktu tunak (${stats.ts.toFixed(2)}s) tergolong lambat.</strong> Sistem membutuhkan waktu yang cukup lama untuk menghilangkan error dan mencapai kondisi stabil. Ini bisa menjadi masalah pada proses yang memerlukan kecepatan tinggi.</p>`;
                } else {
                    html += `<p><strong class="good">Waktu tunak (${stats.ts.toFixed(2)}s) tergolong cepat.</strong> Sistem mampu mencapai dan mempertahankan setpoint dalam waktu yang singkat, menunjukkan kinerja yang efisien dan responsif.</p>`;
                }

                // Interpretasi Error Steady-State (ess)
                if (Math.abs(stats.ess) > 0.05) {
                    html += `<p><strong class="bad">Error steady-state signifikan (${stats.ess.toFixed(3)}).</strong> Sistem tidak mampu mencapai setpoint secara presisi. Ini adalah ciri khas sistem Tipe 0 (seperti kendali P pada plant Tipe 0) yang tidak dapat melacak input step tanpa error. Solusinya adalah dengan menambahkan gain Integral (<code>Ki</code>), yang akan mengubahnya menjadi sistem Tipe 1 dan mengeliminasi error ini.</p>`;
                } else if (Math.abs(stats.ess) > 1e-3) {
                     html += `<p><strong class="warn">Terdapat sedikit error steady-state (${stats.ess.toFixed(3)}).</strong> Kemungkinan besar karena keterbatasan presisi numerik atau gain Integral (<code>Ki</code>) yang terlalu kecil untuk sepenuhnya menghilangkan error dalam waktu singkat.</p>`;
                } else {
                     html += `<p><strong class="good">Error steady-state dapat diabaikan (${stats.ess.toFixed(3)}).</strong> Sistem berhasil mencapai setpoint dengan presisi sangat tinggi, kemungkinan besar berkat adanya aksi kendali Integral (<code>Ki</code> > 0).</p>`;
                }

                return html;
            }

            function generateStabilityInterpretation(poles) {
                 if (poles.length === 0) return `<p>Interpretasi tidak tersedia karena pole tidak dapat dihitung untuk sistem orde lebih tinggi dari 3.</p>`;

                let isUnstable = poles.some(p => p.re > 1e-6);
                if (isUnstable) {
                    return `<p><strong class="bad">Sistem TIDAK STABIL.</strong> Adanya pole di sisi kanan bidang-s (memiliki bagian riil positif) menyebabkan respons sistem tumbuh secara eksponensial tanpa batas. Pada sistem fisik, ini akan berujung pada saturasi aktuator atau kerusakan fatal. Ini adalah kondisi yang harus dihindari dalam desain sistem kendali. Turunkan gain <code>Kp</code> secara drastis atau perkenalkan feedback yang lebih kuat.</p>`;
                }

                let hasComplex = poles.some(p => Math.abs(p.im) > 1e-6);
                let hasRepeated = false;
                if (poles.length > 1) {
                    for(let i=0; i<poles.length; i++){
                        for(let j=i+1; j<poles.length; j++){
                           if(Math.abs(poles[i].re - poles[j].re) < 1e-4 && Math.abs(poles[i].im - poles[j].im) < 1e-4){
                               hasRepeated = true;
                               break;
                           } 
                        }
                        if(hasRepeated) break;
                    }
                }

                if (hasComplex) {
                    // --- PERBAIKAN ---
                    // Kita cari pole-nya dulu, baru kita akses propertinya
                    // untuk menghindari error 'undefined.re'
                    const complexPole = poles.find(p => p.im > 0);
                    const sigma = complexPole ? complexPole.re.toFixed(3) : 'N/A';
                    const omega_d = complexPole ? complexPole.im.toFixed(3) : 'N/A';
                    // --- AKHIR PERBAIKAN ---

                    return `<p><strong class="warn">Sistem Underdamped (Teredam Kurang).</strong> Adanya pasangan pole kompleks konjugat menyebabkan respons sistem berosilasi sebelum mencapai kestabilan.
                        <ul>
                            <li>Bagian Riil (<code>&sigma; = ${sigma}</code>) menentukan seberapa cepat osilasi diredam. Semakin ke kiri (lebih negatif), semakin cepat redamannya.</li>
                            <li>Bagian Imajiner (<code>&omega;d = ${omega_d}</code>) menentukan frekuensi osilasi. Semakin besar, semakin cepat osilasinya.</li>
                        </ul>
                        Ini adalah karakteristik umum pada sistem yang responsif. Contohnya adalah suspensi mobil sport yang sedikit memantul.</p>`;
                } else if (hasRepeated) {
                    return `<p><strong class="good">Sistem Critically Damped (Teredam Kritis).</strong> Adanya pole riil yang berulang (sama) menunjukkan bahwa sistem memberikan respons tercepat yang mungkin tanpa mengalami overshoot. Ini sering dianggap sebagai kondisi ideal dalam banyak aplikasi, seperti gerakan presisi pada sebuah plotter atau robot bedah.</p>`;
                } else {
                     return `<p><strong class="good">Sistem Overdamped (Teredam Lebih).</strong> Semua pole sistem bersifat riil dan berbeda. Hal ini menghasilkan respons yang lambat dan mulus, tanpa osilasi sama sekali. Meskipun sangat stabil, sistem mungkin terlalu lamban untuk beberapa aplikasi. Contohnya adalah pintu hidrolik yang menutup perlahan tanpa membanting.</p>`;
                }
            }
        
        // ==========================================================
        // Bagian 6: Logika Animasi Motor (Tambahan)
        // ==========================================================
            
            /**
             * Memulai loop animasi playback berdasarkan data simulasi.
             */
            function runMotorAnimation(simData, plantType) {
                // Batalkan frame animasi sebelumnya jika ada
                if (currentAnimationId) {
                    cancelAnimationFrame(currentAnimationId);
                }
                
                // Simpan data untuk diakses oleh loop animasi
                animationData = simData;
                animationPlantType = plantType;
                
                // Cek jika simulasi gagal (NaN)
                if (isNaN(animationData.response[animationData.response.length - 1])) {
                     animationStatus.textContent = "Animasi tidak tersedia (Sistem Tidak Stabil)";
                     drawAnimation(0); // Gambar frame dasar
                     currentAnimationId = null;
                     return;
                }

                // Reset state animasi
                animStartTime = 0; // Akan diset pada frame pertama
                animationStatus.textContent = "Memutar ulang respon sistem...";

                // Mulai loop animasi
                currentAnimationId = requestAnimationFrame(animationLoop);
            }

            /**
             * Loop utama animasi (dijalankan oleh requestAnimationFrame)
             */
            function animationLoop(timestamp) {
                if (animStartTime === 0) {
                    animStartTime = timestamp; // Inisialisasi waktu mulai
                }
                
                const elapsedTime = timestamp - animStartTime;
                const progress = Math.min(elapsedTime / animPlaybackDuration, 1.0);
                
                // Tentukan frame data simulasi mana yang akan ditampilkan
                // berdasarkan kemajuan playback (progress 0.0 -> 1.0)
                let animFrameIndex = Math.floor(progress * (animationData.response.length - 1));
                
                if (animFrameIndex >= animationData.response.length) {
                    animFrameIndex = animationData.response.length - 1;
                }

                const currentValue = animationData.response[animFrameIndex];
                drawAnimation(currentValue);

                if (progress < 1.0) {
                    // Lanjutkan loop
                    currentAnimationId = requestAnimationFrame(animationLoop);
                } else {
                    // Selesai
                    animationStatus.textContent = `Animasi selesai. Nilai akhir: ${currentValue.toFixed(3)}`;
                    currentAnimationId = null;
                }
            }

            /**
             * Fungsi penggambaran utama, memilih jenis visualisasi.
             */
            function drawAnimation(value) {
                // Bersihkan canvas
                motorCtx.fillStyle = '#1a1a1a';
                motorCtx.fillRect(0, 0, motorCanvas.width, motorCanvas.height);
                
                // Tentukan jenis animasi
                if (animationPlantType === '2') {
                    // Tipe 2 = Kendali Posisi (Disk berputar)
                    drawPositionDisk(motorCtx, value);
                } else {
                    // Tipe 1 & 3 = Kendali Kecepatan (Gauge/Tachometer)
                    drawSpeedGauge(motorCtx, value);
                }
            }

            /**
             * Menggambar visualisasi Gauge untuk Kendali Kecepatan.
             */
            function drawSpeedGauge(ctx, speed) {
                const centerX = motorCanvas.width / 2;
                const centerY = motorCanvas.height / 2 + 30;
                const radius = 80;
                
                // Normalisasi speed. Asumsikan setpoint 1.0 adalah 100%.
                // Kita beri ruang hingga 1.5x (untuk overshoot)
                const maxDisplaySpeed = 1.5; 
                const angle = (speed / maxDisplaySpeed) * Math.PI; // 0 s/d 180 derajat
                
                // Batasi sudut
                const finalAngle = Math.max(0, Math.min(Math.PI, angle));

                // Gambar busur gauge
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, Math.PI, 0); // Setengah lingkaran
                ctx.strokeStyle = colorBorder; // var(--color-border)
                ctx.lineWidth = 5;
                ctx.stroke();

                // Gambar tanda
                ctx.font = "14px " + fontMono;
                ctx.fillStyle = colorTextDim; // var(--color-text-dim)
                ctx.textAlign = "center";
                ctx.fillText("0", centerX - radius - 15, centerY + 5);
                ctx.fillText("0.5", centerX - radius + 25, centerY - radius + 10);
                ctx.fillText("1.0", centerX + radius - 25, centerY - radius + 10);
                ctx.fillText("1.5+", centerX + radius + 20, centerY + 5);

                // Gambar jarum
                const needleLength = radius - 10;
                // Sudut di canvas: 0 = kanan, PI = kiri. Kita butuh 0 di kiri.
                const needleAngle = Math.PI - finalAngle; 
                const needleX = centerX + needleLength * Math.cos(needleAngle);
                const needleY = centerY - needleLength * Math.sin(needleAngle);
                
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(needleX, needleY);
                ctx.strokeStyle = colorDanger; // var(--color-danger)
                ctx.lineWidth = 3;
                ctx.stroke();

                // Gambar pivot
                ctx.beginPath();
                ctx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
                ctx.fillStyle = colorDanger;
                ctx.fill();

                // Tampilkan nilai
                ctx.font = "bold 24px " + fontMono;
                ctx.fillStyle = colorSecondary; // var(--color-secondary)
                ctx.fillText(speed.toFixed(3), centerX, centerY + 50);
                ctx.font = "16px " + fontMain;
                ctx.fillStyle = colorPrimary; // var(--color-primary)
                ctx.fillText("Kecepatan (rad/s)", centerX, centerY + 80);
            }

            /**
             * Menggambar visualisasi Disk untuk Kendali Posisi.
             */
            function drawPositionDisk(ctx, position) {
                const centerX = motorCanvas.width / 2;
                const centerY = motorCanvas.height / 2 + 30;
                const radius = 80;
                
                // Posisi 1.0 = 1.0 radian
                const angle = position;

                // Gambar disk (motor shaft)
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.fillStyle = colorBgPanel; // var(--color-bg-panel)
                ctx.fill();
                ctx.strokeStyle = colorBorder; // var(--color-border)
                ctx.lineWidth = 4;
                ctx.stroke();
                
                // Sudut 0 di canvas adalah jam 3. Kita offset 90 derajat agar 0 di atas.
                const angleOffset = -Math.PI / 2;

                // Gambar garis referensi (Setpoint = 1 rad)
                const setpointAngle = 1.0 + angleOffset; // 1.0 rad
                const setpointX = centerX + (radius + 15) * Math.cos(setpointAngle);
                const setpointY = centerY + (radius + 15) * Math.sin(setpointAngle);
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(setpointX, setpointY);
                ctx.strokeStyle = colorSecondary; // var(--color-secondary)
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = colorSecondary;
                ctx.font = "14px " + fontMono;
                ctx.textAlign = "center";
                ctx.fillText("1.0", setpointX + 10*Math.cos(setpointAngle), setpointY + 10*Math.sin(setpointAngle) + 5);


                // Gambar garis posisi saat ini
                const currentAngle = angle + angleOffset;
                const lineX = centerX + radius * Math.cos(currentAngle);
                const lineY = centerY + radius * Math.sin(currentAngle);
                
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(lineX, lineY);
                ctx.strokeStyle = colorDanger; // var(--color-danger)
                ctx.lineWidth = 4;
                ctx.stroke();

                // Gambar pivot
                ctx.beginPath();
                ctx.arc(centerX, centerY, 8, 0, 2 * Math.PI);
                ctx.fillStyle = colorDanger;
                ctx.fill();

                // Tampilkan nilai
                ctx.font = "bold 24px " + fontMono;
                ctx.fillStyle = colorSecondary;
                ctx.textAlign = "center";
                ctx.fillText(angle.toFixed(3), centerX, centerY + radius + 30);
                ctx.font = "16px " + fontMain;
                ctx.fillStyle = colorPrimary;
                ctx.fillText("Posisi (rad)", centerX, centerY + radius + 60);
            }

        });
    </script>
</body>
</html>